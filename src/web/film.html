<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>ct film</title>
</head>
<body>
  <h1>fucking stupid tool for filming things</h1>
  <div class="button-row">
    <button id="init">init</button>
    <select id="media_devices"></select>
    <button id="start">start</button>
    <button id="stop" disabled>stop</button>
    time:
    <input type="number" id="second_start" value="0">-<input type="number" id="second_end" value="50">
    <button id="preview_audio">preview audio</button>
    <button>engage boosters</button>
  </div>
  <div class="button-row">
    <input type="text" placeholder="id = " id="groupId">
  </div>
  <div class="row">
    <video id="preview" autoplay muted></video>
  </div>
  <p id="log"></p>

  <script type="module">
    import { uniqueNamesGenerator, adjectives, animals } from 'https://esm.sh/unique-names-generator@4.7.1';

    const groupId = document.getElementById('groupId');
    const initButton = document.getElementById('init');
    const startButton = document.getElementById('start');
    const stopButton = document.getElementById('stop');
    const media_devices = document.getElementById('media_devices');
    const preview = document.getElementById('preview');
    const logElement = document.getElementById('log');
    const secondStart = document.getElementById('second_start');
    const secondEnd = document.getElementById('second_end');
    const preview_audio = document.getElementById('preview_audio');

    function log(msg) {
      logElement.innerHTML += `${msg}\n`;
    }

    log('fetching project data');
    const project = await fetch('/project.json').then(r => r.json());
    const audioBuffer = await fetch('/audio.wav').then(r => r.arrayBuffer());
    log('got metadata and audio for ' + project.name + ' (' + audioBuffer.byteLength + ' bytes)');

    function wait(delayInMS) {
      return new Promise((resolve) => setTimeout(resolve, delayInMS));
    }

    function roundSecondToNearestFrame(seconds) {
      return Math.floor(seconds * 30) / 30;
    }

    const devices = await navigator.mediaDevices.enumerateDevices();
    for (const videoDevice of devices.filter(d => d.kind === 'videoinput')) {
      const option = document.createElement('option');
      option.value = videoDevice.deviceId;
      option.text = videoDevice.label.replace(/\(.+\)/, '').trim();
      media_devices.appendChild(option);
    }

    let stream;

    function resetDefGroupId(params) {
      const groupDefaultId = uniqueNamesGenerator({ dictionaries: [adjectives, animals] });
      groupId.value = '';
      groupId.placeholder = `id = ${groupDefaultId}`;
    }
    
    async function initStream() {
      initButton.disabled = true;

      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            deviceId: media_devices.value,
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            frameRate: 30,
          },
          audio: false,
        });
  
        preview.srcObject = stream;
        preview.captureStream = preview.captureStream;
  
        log('stream initialized');
      } catch (error) {
        log('stream failed to initialize: ' + (error?.stack ?? error));
        initButton.disabled = false;
      }
    }

    initButton.addEventListener('click', initStream);
    initStream().catch(e => log(e));
    media_devices.addEventListener('change', initStream);

    let audioContext = null;
    let audioSource = null;
    let decodedBuffer = null
    async function setupAudioContext() {
      if (audioContext) {
        return;
      }

      audioContext = new AudioContext();
      decodedBuffer = await audioContext.decodeAudioData(audioBuffer);
    }

    function createAudioSource() {
      audioSource = audioContext.createBufferSource();
      audioSource.buffer = decodedBuffer;
      audioSource.loop = true;
      audioSource.loopStart = roundSecondToNearestFrame(secondStart.value);
      audioSource.loopEnd = roundSecondToNearestFrame(secondEnd.value);
      audioSource.connect(audioContext.destination);
    }

    preview_audio.addEventListener('click', async () => {
      await setupAudioContext();
      if (!audioSource) {
        createAudioSource();
        audioSource.start(0, roundSecondToNearestFrame(secondStart.value));
        preview_audio.textContent = 'stop audio';
      } else {
        audioSource.stop();
        audioSource = null;
        preview_audio.textContent = 'preview audio';
      }
    });

    startButton.addEventListener('click', async() => {
      if (audioSource) {
        audioSource.stop();
        audioSource = null;
        preview_audio.textContent = 'preview audio';
      }

      await setupAudioContext();

      const recorder = new MediaRecorder(stream, {
        mimeType: 'video/webm;codecs=vp9',
        videoBitsPerSecond: 10_000_000,
        audioBitsPerSecond: 128_000,
      });

      const chunks = [];
      recorder.addEventListener('dataavailable', (event) => {
        chunks.push(event.data);
      });

      recorder.addEventListener('stop', async () => {
        audioSource.stop();

        const blob = new Blob(chunks, { type: 'video/webm' });
        
        const url = new URL('/take', location.href);
        url.searchParams.set('startFrame', Math.floor(secondStart.value * 30));
        url.searchParams.set('endFrame', Math.floor(secondEnd.value * 30));
        url.searchParams.set('groupId', groupId.value || groupId.placeholder.replace('id = ', ''));

        const r = await fetch(url, {
          method: 'POST',
          body: blob,
          headers: {
            'Content-Type': 'video/webm',
          },
        }).then(r => r.json());
        log('take uploaded: ' + r.path);
      });

      createAudioSource();
      
      audioSource.start(0, roundSecondToNearestFrame(secondStart.value));
      recorder.start(0);

      setTimeout(() => {
        recorder.stop();
      }, roundSecondToNearestFrame(secondEnd.value) * 1000 - roundSecondToNearestFrame(secondStart.value) * 1000);
    });

    secondStart.addEventListener('change', () => {
      secondStart.value = roundSecondToNearestFrame(secondStart.value);
      resetDefGroupId();
    });

    secondEnd.addEventListener('change', () => {
      secondEnd.value = roundSecondToNearestFrame(secondEnd.value);
      resetDefGroupId();
    });

    resetDefGroupId();

  </script>

  <style>
    * { box-sizing: border-box; }
    body {
      font-family: sans-serif;
      height: 100vh;
    }
    .row {
      display: flex;
      flex-direction: row;
    }
    .left, .right {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    video {
      border: 1px solid #ccc;
      width: 500px;
      height: calc(500px * 9 / 16);
    }
    #log {
      color: #666;
      font-family: monospace;
      white-space: pre-wrap;
    }

    input[type=number] {
      width: 70px;
    }
  </style>
</body>
</html>